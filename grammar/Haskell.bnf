{
  parserUtilClass="generated.HaskellParserUtil"

  elementTypeClass="org.jetbrains.haskell.parser.HaskellToken"
  tokenTypeClass  ="org.jetbrains.haskell.parser.HaskellElementType"

  tokens=[
    underscoreId = '_'             // Haskell keywords
    asId = 'as'
    caseId = 'case'
    classId = 'class'
    dataId = 'data'
    defaultId = 'default'
    derivingId = 'deriving'
    doId = 'do'
    elseId = 'else'
    hidingId = 'hiding'
    ifId = 'if'
    importId = 'import'
    inId = 'in'
    infixId = 'infix'
    infixlId = 'infixl'
    infixrId = 'infixr'
    instanceId = 'instance'
    letId = 'let'
    moduleId = 'module'
    newtypeId = 'newtype'
    ofId = 'of'
    qualifiedId = 'qualified'
    thenId = 'then'
    typeId = 'type'
    whereId = 'where'

    forallId = 'forall'    // GHC extension keywords
    foreignId = 'foreign'
    exportId = 'export'
    labelId = 'label'
    dynamicId ='dynamic'
    safeId = 'safe'
    interruptibleId = 'interruptible'
    unsafeId = 'unsafe'
    mdoId = 'mdo'
    familyId = 'family'
    roleId = 'role'
    stdcallId = 'stdcall'
    ccallId = 'ccall'
    capiId = 'capi'
    primId = 'prim'
    javascriptId = 'javascript'
    procId = 'proc'                   // for arrow notation extension
    recId = 'rec'                    // for arrow notation extension
    groupId = 'group'                  // for list transform extension
    byId = 'by'                     // for list transform extension
    usingId ='using'                  // for list transform extension
    patternId ='pattern'                // for pattern synonyms
    BLOCK_COMMENT = 'BLOCK_COMMENT'
    NEW_LINE = '\n'
/*
 '{-# INLINE'             { L _ (ITinline_prag _ _) }
 '{-# SPECIALISE'         { L _ ITspec_prag }
 '{-# SPECIALISE_INLINE'  { L _ (ITspec_inline_prag _) }
 '{-# SOURCE'                                   { L _ ITsource_prag }
 '{-# RULES'                                    { L _ ITrules_prag }
 '{-# CORE'                                     { L _ ITcore_prag }              -- hdaume: annotated core
 '{-# SCC'                { L _ ITscc_prag }
 '{-# GENERATED'          { L _ ITgenerated_prag }
 '{-# DEPRECATED'         { L _ ITdeprecated_prag }
 '{-# WARNING'            { L _ ITwarning_prag }
 '{-# UNPACK'             { L _ ITunpack_prag }
 '{-# NOUNPACK'           { L _ ITnounpack_prag }
 '{-# ANN'                { L _ ITann_prag }
 '{-# VECTORISE'          { L _ ITvect_prag }
 '{-# VECTORISE_SCALAR'   { L _ ITvect_scalar_prag }
 '{-# NOVECTORISE'        { L _ ITnovect_prag }
 '{-# MINIMAL'            { L _ ITminimal_prag }
 '{-# CTYPE'              { L _ ITctype }
 '{-# OVERLAPPING'        { L _ IToverlapping_prag }
 '{-# OVERLAPPABLE'       { L _ IToverlappable_prag }
 '{-# OVERLAPS'           { L _ IToverlaps_prag }
 '{-# INCOHERENT'         { L _ ITincoherent_prag }
 '#-}'                                          { L _ ITclose_prag }

 '..'           { L _ ITdotdot }                        -- reserved symbols
 ':'            { L _ ITcolon }
 '::'           { L _ ITdcolon }
 '='            { L _ ITequal }
 '\\'           { L _ ITlam }
 'lcase'        { L _ ITlcase }
 '|'            { L _ ITvbar }
 '<-'           { L _ ITlarrow }
 '->'           { L _ ITrarrow }
 '@'            { L _ ITat }
 '~'            { L _ ITtilde }
 '~#'           { L _ ITtildehsh }
 '=>'           { L _ ITdarrow }
 '-'            { L _ ITminus }
 '!'            { L _ ITbang }
 '*'            { L _ ITstar }
 '-<'           { L _ ITlarrowtail }            -- for arrow notation
 '>-'           { L _ ITrarrowtail }            -- for arrow notation
 '-<<'          { L _ ITLarrowtail }            -- for arrow notation
 '>>-'          { L _ ITRarrowtail }            -- for arrow notation
 */
 dot = '.'
 ocurlyId = '{'
 ccurlyId = '}'
 vocurly = 'vocurly'
 vccurly = 'vccurly'
 vsemicolon = 'vsemicolon'
 /*
 '['            { L _ ITobrack }
 ']'            { L _ ITcbrack }
 '[:'           { L _ ITopabrack }
 ':]'           { L _ ITcpabrack }
 '('            { L _ IToparen }
 ')'            { L _ ITcparen }
 '(#'           { L _ IToubxparen }
 '#)'           { L _ ITcubxparen }
 '(|'           { L _ IToparenbar }
 '|)'           { L _ ITcparenbar }
 ';'            { L _ ITsemi }
 ','            { L _ ITcomma }
 '`'            { L _ ITbackquote }
 SIMPLEQUOTE    { L _ ITsimpleQuote      }     -- 'x
*/
 VARID = 'VARID'
 CONID = 'CONID'
/*
 VARSYM         { L _ (ITvarsym   _) }
 CONSYM         { L _ (ITconsym   _) }
 QVARID         { L _ (ITqvarid   _) }
 QCONID         { L _ (ITqconid   _) }
 QVARSYM        { L _ (ITqvarsym  _) }
 QCONSYM        { L _ (ITqconsym  _) }
 PREFIXQVARSYM  { L _ (ITprefixqvarsym  _) }
 PREFIXQCONSYM  { L _ (ITprefixqconsym  _) }

 IPDUPVARID     { L _ (ITdupipvarid   _) }              -- GHC extension

 CHAR           { L _ (ITchar     _) }
 STRING         { L _ (ITstring   _) }
 INTEGER        { L _ (ITinteger  _) }
 RATIONAL       { L _ (ITrational _) }

 PRIMCHAR       { L _ (ITprimchar   _) }
 PRIMSTRING     { L _ (ITprimstring _) }
 PRIMINTEGER    { L _ (ITprimint    _) }
 PRIMWORD       { L _ (ITprimword  _) }
 PRIMFLOAT      { L _ (ITprimfloat  _) }
 PRIMDOUBLE     { L _ (ITprimdouble _) }

 DOCNEXT        { L _ (ITdocCommentNext _) }
 DOCPREV        { L _ (ITdocCommentPrev _) }
 DOCNAMED       { L _ (ITdocCommentNamed _) }
 DOCSECTION     { L _ (ITdocSection _ _) }

-- Template Haskell
'[|'            { L _ ITopenExpQuote  }
'[p|'           { L _ ITopenPatQuote  }
'[t|'           { L _ ITopenTypQuote  }
'[d|'           { L _ ITopenDecQuote  }
'|]'            { L _ ITcloseQuote    }
'[||'           { L _ ITopenTExpQuote   }
'||]'           { L _ ITcloseTExpQuote  }
TH_ID_SPLICE    { L _ (ITidEscape _)  }     -- $x
'$('            { L _ ITparenEscape   }     -- $( exp )
TH_ID_TY_SPLICE { L _ (ITidTyEscape _)  }   -- $$x
'$$('           { L _ ITparenTyEscape   }   -- $$( exp )
TH_TY_QUOTE     { L _ ITtyQuote       }      -- ''T
TH_QUASIQUOTE   { L _ (ITquasiQuote _) }
TH_QQUASIQUOTE  { L _ (ITqQuasiQuote _) }
*/
  ]
}

root ::= module

QCONID ::= (CONID '.')* CONID

modid   ::=
          CONID
        | QCONID

module ::= 'module' modid 'where' body

body ::= rest

rest ::= any*

any ::= !<<eof>>