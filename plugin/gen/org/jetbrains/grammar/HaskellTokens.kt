package org.jetbrains.grammar

import com.intellij.psi.tree.IElementType
import org.jetbrains.haskell.parser.HaskellCompositeElementType
import org.jetbrains.haskell.psi.*


object HaskellTokens {
  val MODULE = HaskellCompositeElementType("module", ::Module)
  val MAYBEDOCHEADER = HaskellCompositeElementType("maybedocheader")
  val MISSING_MODULE_KEYWORD = HaskellCompositeElementType("missing_module_keyword")
  val MAYBEMODWARNING = HaskellCompositeElementType("maybemodwarning")
  val BODY = HaskellCompositeElementType("body")
  val BODY2 = HaskellCompositeElementType("body2")
  val TOP = HaskellCompositeElementType("top")
  val CVTOPDECLS = HaskellCompositeElementType("cvtopdecls")
  val HEADER = HaskellCompositeElementType("header")
  val HEADER_BODY = HaskellCompositeElementType("header_body")
  val HEADER_BODY2 = HaskellCompositeElementType("header_body2")
  val MAYBEEXPORTS = HaskellCompositeElementType("maybeexports")
  val EXPORTLIST = HaskellCompositeElementType("exportlist")
  val EXPORTLIST1 = HaskellCompositeElementType("exportlist1")
  val EXPDOCLIST = HaskellCompositeElementType("expdoclist")
  val EXP_DOC = HaskellCompositeElementType("exp_doc")
  val EXPORT = HaskellCompositeElementType("export")
  val EXPORT_SUBSPEC = HaskellCompositeElementType("export_subspec")
  val QCNAMES = HaskellCompositeElementType("qcnames")
  val QCNAME_EXT = HaskellCompositeElementType("qcname_ext")
  val QCNAME = HaskellCompositeElementType("qcname")
  val IMPORTDECLS = HaskellCompositeElementType("importdecls")
  val IMPORTDECL = HaskellCompositeElementType("importdecl")
  val MAYBE_SRC = HaskellCompositeElementType("maybe_src")
  val MAYBE_SAFE = HaskellCompositeElementType("maybe_safe")
  val MAYBE_PKG = HaskellCompositeElementType("maybe_pkg")
  val OPTQUALIFIED = HaskellCompositeElementType("optqualified")
  val MAYBEAS = HaskellCompositeElementType("maybeas")
  val MAYBEIMPSPEC = HaskellCompositeElementType("maybeimpspec")
  val IMPSPEC = HaskellCompositeElementType("impspec")
  val PREC = HaskellCompositeElementType("prec")
  val INFIX = HaskellCompositeElementType("infix")
  val OPS = HaskellCompositeElementType("ops")
  val TOPDECLS = HaskellCompositeElementType("topdecls")
  val TOPDECL = HaskellCompositeElementType("topdecl")
  val CL_DECL = HaskellCompositeElementType("cl_decl")
  val TY_DECL = HaskellCompositeElementType("ty_decl")
  val INST_DECL = HaskellCompositeElementType("inst_decl")
  val OVERLAP_PRAGMA = HaskellCompositeElementType("overlap_pragma")
  val WHERE_TYPE_FAMILY = HaskellCompositeElementType("where_type_family")
  val TY_FAM_INST_EQN_LIST = HaskellCompositeElementType("ty_fam_inst_eqn_list")
  val TY_FAM_INST_EQNS = HaskellCompositeElementType("ty_fam_inst_eqns")
  val TY_FAM_INST_EQN = HaskellCompositeElementType("ty_fam_inst_eqn")
  val AT_DECL_CLS = HaskellCompositeElementType("at_decl_cls")
  val OPT_FAMILY = HaskellCompositeElementType("opt_family")
  val AT_DECL_INST = HaskellCompositeElementType("at_decl_inst")
  val DATA_OR_NEWTYPE = HaskellCompositeElementType("data_or_newtype")
  val OPT_KIND_SIG = HaskellCompositeElementType("opt_kind_sig")
  val TYCL_HDR = HaskellCompositeElementType("tycl_hdr")
  val CAPI_CTYPE = HaskellCompositeElementType("capi_ctype")
  val STAND_ALONE_DERIVING = HaskellCompositeElementType("stand_alone_deriving")
  val ROLE_ANNOT = HaskellCompositeElementType("role_annot")
  val MAYBE_ROLES = HaskellCompositeElementType("maybe_roles")
  val ROLES = HaskellCompositeElementType("roles")
  val ROLE = HaskellCompositeElementType("role")
  val PATTERN_SYNONYM_DECL = HaskellCompositeElementType("pattern_synonym_decl")
  val WHERE_DECLS = HaskellCompositeElementType("where_decls")
  val VARS0 = HaskellCompositeElementType("vars0")
  val DECL_CLS = HaskellCompositeElementType("decl_cls")
  val DECLS_CLS = HaskellCompositeElementType("decls_cls")
  val DECLLIST_CLS = HaskellCompositeElementType("decllist_cls")
  val WHERE_CLS = HaskellCompositeElementType("where_cls")
  val DECL_INST = HaskellCompositeElementType("decl_inst")
  val DECLS_INST = HaskellCompositeElementType("decls_inst")
  val DECLLIST_INST = HaskellCompositeElementType("decllist_inst")
  val WHERE_INST = HaskellCompositeElementType("where_inst")
  val DECLS = HaskellCompositeElementType("decls")
  val DECLLIST = HaskellCompositeElementType("decllist")
  val BINDS = HaskellCompositeElementType("binds")
  val WHEREBINDS = HaskellCompositeElementType("wherebinds")
  val STRINGS = HaskellCompositeElementType("strings")
  val STRINGLIST = HaskellCompositeElementType("stringlist")
  val OPT_SIG = HaskellCompositeElementType("opt_sig")
  val OPT_ASIG = HaskellCompositeElementType("opt_asig")
  val SIGTYPE = HaskellCompositeElementType("sigtype")
  val SIGTYPEDOC = HaskellCompositeElementType("sigtypedoc")
  val SIG_VARS = HaskellCompositeElementType("sig_vars")
  val SIGTYPES1 = HaskellCompositeElementType("sigtypes1")
  val STRICT_MARK = HaskellCompositeElementType("strict_mark")
  val CTYPE = HaskellCompositeElementType("ctype")
  val CTYPEDOC = HaskellCompositeElementType("ctypedoc")
  val CONTEXT = HaskellCompositeElementType("context")
  val TYPE = HaskellCompositeElementType("type")
  val TYPEDOC = HaskellCompositeElementType("typedoc")
  val BTYPE = HaskellCompositeElementType("btype")
  val ATYPE = HaskellCompositeElementType("atype")
  val INST_TYPE = HaskellCompositeElementType("inst_type")
  val INST_TYPES1 = HaskellCompositeElementType("inst_types1")
  val COMMA_TYPES0 = HaskellCompositeElementType("comma_types0")
  val COMMA_TYPES1 = HaskellCompositeElementType("comma_types1")
  val TV_BNDRS = HaskellCompositeElementType("tv_bndrs")
  val TV_BNDR = HaskellCompositeElementType("tv_bndr")
  val FDS = HaskellCompositeElementType("fds")
  val FDS1 = HaskellCompositeElementType("fds1")
  val FD = HaskellCompositeElementType("fd")
  val VARIDS0 = HaskellCompositeElementType("varids0")
  val KIND = HaskellCompositeElementType("kind")
  val BKIND = HaskellCompositeElementType("bkind")
  val AKIND = HaskellCompositeElementType("akind")
  val PKIND = HaskellCompositeElementType("pkind")
  val COMMA_KINDS1 = HaskellCompositeElementType("comma_kinds1")
  val GADT_CONSTRLIST = HaskellCompositeElementType("gadt_constrlist")
  val GADT_CONSTRS = HaskellCompositeElementType("gadt_constrs")
  val GADT_CONSTR = HaskellCompositeElementType("gadt_constr")
  val CONSTRS = HaskellCompositeElementType("constrs")
  val CONSTRS1 = HaskellCompositeElementType("constrs1")
  val CONSTR = HaskellCompositeElementType("constr")
  val FORALL = HaskellCompositeElementType("forall")
  val CONSTR_STUFF = HaskellCompositeElementType("constr_stuff")
  val FIELDDECLS = HaskellCompositeElementType("fielddecls")
  val FIELDDECLS1 = HaskellCompositeElementType("fielddecls1")
  val FIELDDECL = HaskellCompositeElementType("fielddecl")
  val DERIVING = HaskellCompositeElementType("deriving")
  val DOCDECL = HaskellCompositeElementType("docdecl")
  val DOCDECLD = HaskellCompositeElementType("docdecld")
  val DECL_NO_TH = HaskellCompositeElementType("decl_no_th")
  val DECL = HaskellCompositeElementType("decl")
  val RHS = HaskellCompositeElementType("rhs")
  val GDRHS = HaskellCompositeElementType("gdrhs")
  val GDRH = HaskellCompositeElementType("gdrh")
  val SIGDECL = HaskellCompositeElementType("sigdecl")
  val ACTIVATION = HaskellCompositeElementType("activation")
  val EXPLICIT_ACTIVATION = HaskellCompositeElementType("explicit_activation")
  val QUASIQUOTE = HaskellCompositeElementType("quasiquote")
  val EXP = HaskellCompositeElementType("exp")
  val INFIXEXP = HaskellCompositeElementType("infixexp")
  val EXP10 = HaskellCompositeElementType("exp10")
  val OPTSEMI = HaskellCompositeElementType("optSemi")
  val SCC_ANNOT = HaskellCompositeElementType("scc_annot")
  val HPC_ANNOT = HaskellCompositeElementType("hpc_annot")
  val FEXP = HaskellCompositeElementType("fexp")
  val AEXP = HaskellCompositeElementType("aexp")
  val AEXP1 = HaskellCompositeElementType("aexp1")
  val AEXP2 = HaskellCompositeElementType("aexp2")
  val SPLICE_EXP = HaskellCompositeElementType("splice_exp")
  val CMDARGS = HaskellCompositeElementType("cmdargs")
  val ACMD = HaskellCompositeElementType("acmd")
  val CVTOPBODY = HaskellCompositeElementType("cvtopbody")
  val CVTOPDECLS0 = HaskellCompositeElementType("cvtopdecls0")
  val DBINDS = HaskellCompositeElementType("dbinds")
  val DBIND = HaskellCompositeElementType("dbind")
  val IPVAR = HaskellCompositeElementType("ipvar")
  val GTYCON = HaskellCompositeElementType("gtycon")
  val NTGTYCON = HaskellCompositeElementType("ntgtycon")
  val OQTYCON = HaskellCompositeElementType("oqtycon")
  val QTYCONOP = HaskellCompositeElementType("qtyconop")
  val QTYCON = HaskellCompositeElementType("qtycon")
  val TYCON = HaskellCompositeElementType("tycon")
  val QTYCONSYM = HaskellCompositeElementType("qtyconsym")
  val TYCONSYM = HaskellCompositeElementType("tyconsym")
  val OP = HaskellCompositeElementType("op")
  val VAROP = HaskellCompositeElementType("varop")
  val QOP = HaskellCompositeElementType("qop")
  val QOPM = HaskellCompositeElementType("qopm")
  val QVAROP = HaskellCompositeElementType("qvarop")
  val QVAROPM = HaskellCompositeElementType("qvaropm")
  val TYVAR = HaskellCompositeElementType("tyvar")
  val TYVAROP = HaskellCompositeElementType("tyvarop")
  val TYVARID = HaskellCompositeElementType("tyvarid")
  val VAR = HaskellCompositeElementType("var")
  val QVAR = HaskellCompositeElementType("qvar")
  val QVARID = HaskellCompositeElementType("qvarid")
  val VARID = HaskellCompositeElementType("varid")
  val QVARSYM = HaskellCompositeElementType("qvarsym")
  val QVARSYM_NO_MINUS = HaskellCompositeElementType("qvarsym_no_minus")
  val QVARSYM1 = HaskellCompositeElementType("qvarsym1")
  val VARSYM = HaskellCompositeElementType("varsym")
  val VARSYM_NO_MINUS = HaskellCompositeElementType("varsym_no_minus")
  val SPECIAL_ID = HaskellCompositeElementType("special_id")
  val SPECIAL_SYM = HaskellCompositeElementType("special_sym")
  val LITERAL = HaskellCompositeElementType("literal")
  val CLOSE = HaskellCompositeElementType("close")
  val MODID = HaskellCompositeElementType("modid")
  val COMMAS = HaskellCompositeElementType("commas")
  val DOCNEXT = HaskellCompositeElementType("docnext")
  val DOCPREV = HaskellCompositeElementType("docprev")
  val DOCNAMED = HaskellCompositeElementType("docnamed")
  val DOCSECTION = HaskellCompositeElementType("docsection")
  val MODULEHEADER = HaskellCompositeElementType("moduleheader")
  val MAYBE_DOCPREV = HaskellCompositeElementType("maybe_docprev")
  val MAYBE_DOCNEXT = HaskellCompositeElementType("maybe_docnext")
}
